<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Vincent Durmont</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat"
      rel="stylesheet"
    />
    <link rel="stylesheet" type="text/css" href="/assets/css/vdurmont.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/css/prism-hopscotch.css"
    />
  </head>
  <body>
    <div class="page">
      <h1 class="title"><a href="/">Vincent Durmont</a></h1>
      
<p><a href="/">&laquo; Back</a></p>

<p class="blog-date">January 27, 2014</p>
<h1 class="blog-title">Checked VS unchecked exceptions... Fail fast!</h1>
<p>The debate is as old as Java itself: should we use <em>checked</em> or <em>unchecked</em> exceptions when there is an error? After reading A LOT of posts on the subject and chatting with lots of developers, I concluded that there is no right answer.</p>
<p>In my apps, I chose to <strong>fail fast</strong>. Let's see what it means.</p>
<!--more-->
<h1>Definition</h1>
<p>For those in the back of the class who forgot their Java basics, here is a quick reminder.</p>
<p>A <strong>checked exception</strong> inherits from <code>java.lang.Exception</code> and is part of the signature of the methods throwing it:</p>
<p><code>public void someMethod() throws Exception { /* Do stuff */ }</code></p>
<p>Common examples of checked exceptions are: <code>java.io.IOException</code>, <code>java.sql.SQLException</code>, etc.</p>
<p>An <strong>unchecked exception</strong> inherits from <code>java.lang.RuntimeException</code> and doesn't need to be catched if the developer doesn't feel the need to do it. If it is not catched, it bubbles up to the top of the program.</p>
<p>Common examples of unchecked exceptions are: <code>java.lang.NullPointerException</code>, <code>java.lang.IndexOutOfBoundsException</code>, <code>java.lang.IllegalArgumentException</code>, etc.</p>
<p>The <a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/runtime.html">official guide</a> basically says that &quot;<em>If a client can reasonably be expected to recover from an exception, make it a checked exception. If a client cannot do anything to recover from the exception, make it an unchecked exception.</em>&quot;</p>
<h1>Fail-fast</h1>
<p>Failing fast means to immediately stop the execution of a program and report back to the user when encountering a condition that is likely to lead to failure (<a href="http://en.wikipedia.org/wiki/Fail-fast">Wikipedia</a>).</p>
<p>In order to avoid any useless costly operation, I like to fail fast in my programs. If something seems wrong, I prefer to stop the execution right away and report to the user. For me the user is <em>very</em> often another application, requesting my APIs via a web request. It means that there is almost no way that my application can recover from an exception.</p>
<p>All I want to do is let the exception bubble up to the top of the program where I placed an <a href="http://docs.spring.io/spring/docs/4.0.0.RELEASE/javadoc-api/org/springframework/web/servlet/HandlerExceptionResolver.html">ExceptionResolver</a> (or something similar) where I handle all the errors and return an appropriate status code (in the case of a REST application). The best way for me to do that is to use <em>unchecked</em> exceptions.</p>
<h1>Not failing fast: <code>java.util.HashMap</code></h1>
<p>The <code>HashMap</code> class is, in my opinion, not failing fast enought. Here is an illustration:</p>
<p>public class MapFailsSlowly {
public static void main(String[] args) {
Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put(&quot;foo&quot;, &quot;my foo string&quot;);
map.put(&quot;bar&quot;, &quot;my bar string&quot;);</p>
<p>// Code code code</p>
<p>String value = map.get(&quot;baz&quot;);
System.out.println(&quot;&quot;baz&quot; value's length: &quot; + value.length());
}
}</p>
<p>Running this code will throw a <code>NullPointerException</code> with this stacktrace:</p>
<p>Exception in thread &quot;main&quot; java.lang.NullPointerException
at com.ligati.failfast.MapFailsSlowly.main(MapFailsSlowly.java:20)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)</p>
<p>Awesome. This really helps me. It tells me that my value is null, but it is not the line where I got it so the context is not ideal. And its a really simple code, imagine that I got <code>value</code> from another method, I would fail in a portion of the code that has nothing to do with the retrieval of the value.</p>
<p>I'd prefer this implementation:</p>
<p>public class FastFailingMap&lt;K, V&gt; extends HashMap&lt;K, V&gt; {
@Override
public V get(Object key) {
V value = super.get(key);
if (value == null)
throw new KeyNotFoundException(key);
return value;
}</p>
<p>public static class KeyNotFoundException extends IllegalStateException {
public KeyNotFoundException(Object key) {
super(&quot;The key '&quot; + key + &quot;' is not present in the map.&quot;);
}
}
}</p>
<p>When running the previous code with a <code>FastFailingMap</code> instead of a <code>HashMap</code>, I obtain the following exception.</p>
<p>Exception in thread &quot;main&quot; com.ligati.failfast.FastFailingMap$KeyNotFoundException: The key 'baz' is not present in the map.
at com.ligati.failfast.FastFailingMap.get(FastFailingMap.java:10)
at com.ligati.failfast.MapFailsFast.main(MapFailsFast.java:16)
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
at java.lang.reflect.Method.invoke(Method.java:606)
at com.intellij.rt.execution.application.AppMain.main(AppMain.java:120)</p>
<p>It is much better: the code fails exactly when it tries to access the unknown entry and also provide a clear error message which will help to solve the problem.</p>
<p>However, I suppose that <code>null</code> is not a valid value but in my code, it is rarely the case. In general, when we perform an operation on a null object, it means that there is something wrong somewhere.</p>
<h1>Conclusion</h1>
<p>I finally chose to use unchecked exceptions in all my apps because...</p>
<ul>
<li>I can almost never recover from an exception in my apps</li>
<li>I want to let the exceptions bubble to the top of the app where they are translated into an appropriate status code/error message</li>
<li>I like when my code fails where the problem is and not 10 lines later and that is the best way to do it without handling tons of exceptions</li>
<li>Consequence of the previous point: I can provide my end users with elegant error messages because I know what happened when the exception is thrown</li>
</ul>
<p>What about you? Which kind of exception do you use?</p>


    </div>
  </body>
</html>
