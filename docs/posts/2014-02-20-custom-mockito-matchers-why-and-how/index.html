<!DOCTYPE html>

<html lang="en">
  <head>
    <title>Vincent Durmont</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css?family=Montserrat"
      rel="stylesheet"
    />
    <link rel="stylesheet" type="text/css" href="/assets/css/vdurmont.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="/assets/css/prism-hopscotch.css"
    />
  </head>
  <body>
    <div class="page">
      <h1 class="title"><a href="/">Vincent Durmont</a></h1>
      
<p><a href="/">&laquo; Back</a></p>

<p class="blog-date">February 20, 2014</p>
<h1 class="blog-title">Custom Mockito matchers</h1>
<p><a href="http://mockito.org">Mockito</a> is an awesome mocking framework that helps you simulate objects and services which have a complex or non-deterministic behavior in your unit tests.</p>
<p>When I check if there are interactions with some of the mocks, I sometimes want to perform custom verifications. In order to do that, let's see how to write custom matchers with Mockito!</p>
<!--more-->
<h1>Basic usage</h1>
<p>Here is a basic example of how to check if a mock is called. We have a service <code>MyService</code> which has a method <code>doStuff()</code> which sends a message.</p>
<p>public class MyService {
private final MessageService messageService;</p>
<p>public MyService(MessageService messageService) {
this.messageService = messageService;
}</p>
<p>public void doStuff(Human author) {
// TODO do complex stuff</p>
<p>Message message = new Message(author);
this.messageService.send(message);</p>
<p>// TODO do complex stuff again
}
}</p>
<p>public class Message {
private final Human author;</p>
<p>public Message(Human author) {
this.author = author;
}</p>
<p>public Human getAuthor() {
return author;
}
}</p>
<p>public class Human {
private final String name;
private final Gender gender;</p>
<p>public Human(String name, Gender gender) {
this.name = name;
this.gender = gender;
}</p>
<p>public String getName() {
return name;
}</p>
<p>public Gender getGender() {
return gender;
}
}</p>
<p>public class MessageService {
public void send(Message message) {
// TODO send the message :)
}
}</p>
<p>We can write a test that checks that a message is sent when we <code>doStuff()</code>:</p>
<p>@RunWith(JUnit4.class)
public class MyServiceTest {
@Test
public void doStuff_sends_a_message() {
// GIVEN
MessageService mockMessageService = mock(MessageService.class);
MyService service = new MyService(mockMessageService);</p>
<p>Human author = new Human(&quot;Vincent&quot;, Gender.MALE);</p>
<p>// WHEN
service.doStuff(author);</p>
<p>// THEN
verify(mockMessageService).send(any(Message.class));
}
}</p>
<p>As you can see, Mockito enables us to simulate the <code>MessageService</code> in order to check that it is correctly called. But in this case, we have no way to compare the author of the sent message with our <code>author</code> variable.</p>
<h1>Matcher without argument</h1>
<p>Let's write a custom matcher that will replace the <code>any(Message.class)</code> and check that the author is a male. The test would look like:</p>
<p>@Test
public void doStuff_sends_a_message_from_a_male() {
// GIVEN
MessageService mockMessageService = mock(MessageService.class);
MyService service = new MyService(mockMessageService);</p>
<p>Human author = new Human(&quot;Vincent&quot;, Gender.MALE);</p>
<p>// WHEN
service.doStuff(author);</p>
<p>// THEN
verify(mockMessageService).send(authorIsAMale());
}</p>
<p>Here is the custom matcher:</p>
<p>public class MaleMatcher extends ArgumentMatcher<Message> {
public static Message authorIsAMale() {
return argThat(new MaleMatcher());
}</p>
<p>@Override
public boolean matches(Object argument) {
// TODO check null, etc.
return Gender.MALE.equals(((Message) argument).getAuthor().getGender());
}
}</p>
<h1>Matcher with arguments</h1>
<p>Now let's say we want to compare the beginning of the author's name of the sent message with a String. Here is how it works:</p>
<p>@Test
public void doStuff_sends_a_message_from_an_author_whose_name_starts_with_V() {
// GIVEN
MessageService mockMessageService = mock(MessageService.class);
MyService service = new MyService(mockMessageService);</p>
<p>Human author = new Human(&quot;Vincent&quot;, Gender.MALE);</p>
<p>// WHEN
service.doStuff(author);</p>
<p>// THEN
verify(mockMessageService).send(authorNameStartsWith(&quot;v&quot;));
}</p>
<p>public class AuthorNameMatcher extends ArgumentMatcher<Message> {
public static Message authorNameStartsWith(String startsWith) {
return argThat(new AuthorNameMatcher(startsWith));
}</p>
<p>private final String expected;</p>
<p>public AuthorNameMatcher(String expected) {
this.expected = expected;
}</p>
<p>@Override
public boolean matches(Object argument) {
// TODO check null, etc.
String actual = ((Message) argument).getAuthor().getName().toLowerCase();
return actual.startsWith(expected.toLowerCase());
}
}</p>
<h1>Going further</h1>
<p>Do not forget that you can override the <code>describeTo</code> method in the matchers. It will enable you to display custom error messages!</p>
<p>You can find <a href="https://github.com/vdurmont/custom-mockito-matchers-example">the code on Github</a>.</p>
<p>I hope it will be useful for you!</p>


    </div>
  </body>
</html>
